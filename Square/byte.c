/* 
 * SQUARE reference implementation.
 *
 * Algorithm developed by Joan Daemen <joan.daemen@club.innet.be> and
 * Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>
 *
 * Version 2.0.1 (1997.02.07)
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.        
 */

/*
 * This a byte level implementation.
 * a[0] corresponds with the first byte of the plaintext block,
 * a[0xF] with the last one. same for the ciphertext and the key.
 */

#include <stdio.h>
#include <stdlib.h>


#define R 8		 /* number of rounds	  */
#define ROOT 0x1f5U	 /* polynomial for generating GF(2^8) */

typedef unsigned short		word16;	/* 16 bit */

word16 S_GAMMA[0x100] =
{0xb1,0xce,0xc3,0x95,0x5a,0xad,0xe7,0x02,0x4d,0x44,0xfb,0x91,0x0c,0x87,0xa1,0x50,
 0xcb,0x67,0x54,0xdd,0x46,0x8f,0xe1,0x4e,0xf0,0xfd,0xfc,0xeb,0xf9,0xc4,0x1a,0x6e,
 0x5e,0xf5,0xcc,0x8d,0x1c,0x56,0x43,0xfe,0x07,0x61,0xf8,0x75,0x59,0xff,0x03,0x22,
 0x8a,0xd1,0x13,0xee,0x88,0x00,0x0e,0x34,0x15,0x80,0x94,0xe3,0xed,0xb5,0x53,0x23,
 0x4b,0x47,0x17,0xa7,0x90,0x35,0xab,0xd8,0xb8,0xdf,0x4f,0x57,0x9a,0x92,0xdb,0x1b,
 0x3c,0xc8,0x99,0x04,0x8e,0xe0,0xd7,0x7d,0x85,0xbb,0x40,0x2c,0x3a,0x45,0xf1,0x42,
 0x65,0x20,0x41,0x18,0x72,0x25,0x93,0x70,0x36,0x05,0xf2,0x0b,0xa3,0x79,0xec,0x08,
 0x27,0x31,0x32,0xb6,0x7c,0xb0,0x0a,0x73,0x5b,0x7b,0xb7,0x81,0xd2,0x0d,0x6a,0x26,
 0x9e,0x58,0x9c,0x83,0x74,0xb3,0xac,0x30,0x7a,0x69,0x77,0x0f,0xae,0x21,0xde,0xd0,
 0x2e,0x97,0x10,0xa4,0x98,0xa8,0xd4,0x68,0x2d,0x62,0x29,0x6d,0x16,0x49,0x76,0xc7,
 0xe8,0xc1,0x96,0x37,0xe5,0xca,0xf4,0xe9,0x63,0x12,0xc2,0xa6,0x14,0xbc,0xd3,0x28,
 0xaf,0x2f,0xe6,0x24,0x52,0xc6,0xa0,0x09,0xbd,0x8c,0xcf,0x5d,0x11,0x5f,0x01,0xc5,
 0x9f,0x3d,0xa2,0x9b,0xc9,0x3b,0xbe,0x51,0x19,0x1f,0x3f,0x5c,0xb2,0xef,0x4a,0xcd,
 0xbf,0xba,0x6f,0x64,0xd9,0xf3,0x3e,0xb4,0xaa,0xdc,0xd5,0x06,0xc0,0x7e,0xf6,0x66,
 0x6c,0x84,0x71,0x38,0xb9,0x1d,0x7f,0x9d,0x48,0x8b,0x2a,0xda,0xa5,0x33,0x82,0x39,
 0xd6,0x78,0x86,0xfa,0xe4,0x2b,0xa9,0x1e,0x89,0x60,0x6b,0xea,0x55,0x4c,0xf7,0xe2} ;


word16 xtime(word16 x) {
   /* multiply with 2 in the Galois Field
    */
   x <<= 1;
   if (0 != (x&0x100)) x ^= ROOT;
   return x;
   }

void theta(word16 *a) {
   int i, j;
   word16 b[16];
   for(i = 0; i < 4; i++) {
      for(j = 0; j < 4; j++) {   
	 b[4*i+j]  = xtime(a[4*i +   j]);
	 b[4*i+j] ^=	a[4*i + ((j+1)%4)];
	 b[4*i+j] ^= xtime(a[4*i + ((j+1)%4)]);
	 b[4*i+j] ^=	a[4*i + ((j+2)%4)];
	 b[4*i+j] ^=	a[4*i + ((j+3)%4)];
	 }
      }
   for(j = 0; j < 16; j++) a[j] = b[j] ;
   }

void gamma(word16 *a) {
   int i;
   for(i = 0; i < 16; i++) {
      a[i] = S_GAMMA[a[i]] ;
      }
   }

void pi(word16 *a) {
   word16 tmp;
   tmp = a[1]; a[1] = a[4]; a[4] = tmp;
   tmp = a[2]; a[2] = a[8]; a[8] = tmp;
   tmp = a[6]; a[6] = a[9]; a[9] = tmp;
   tmp = a[3]; a[3] = a[0xC]; a[0xC] = tmp;
   tmp = a[7]; a[7] = a[0xD]; a[0xD] = tmp;
   tmp = a[0xB]; a[0xB] = a[0xE]; a[0xE] = tmp;
   }

void sigma(word16 *a, word16 *rk) {
   int i;
   for(i = 0; i < 16; i++) a[i] ^= rk[i] ;
   }

void keysched(word16 *rk, word16 *prcon) {
   word16 tmp;
   tmp = rk[0xC];
   rk[0] ^= *prcon;
   rk[0] ^= rk[0xD]; rk[4] ^= rk[0]; rk[8] ^= rk[4]; rk[0xC] ^= rk[8];
   rk[1] ^= rk[0xE]; rk[5] ^= rk[1]; rk[9] ^= rk[5]; rk[0xD] ^= rk[9];
   rk[2] ^= rk[0xF]; rk[6] ^= rk[2]; rk[0xA] ^= rk[6]; rk[0xE] ^= rk[0xA];
   rk[3] ^= tmp	; rk[7] ^= rk[3]; rk[0xB] ^= rk[7]; rk[0xF] ^= rk[0xB];
   *prcon = xtime(*prcon);
   }

void square(word16 *a, word16 *k) {
   word16 rcon, rk[16];
   int i;
   rcon = 1;
   for(i = 0; i < 16; i++) rk[i] = k[i];
   theta(rk);   /*  sigma(theta(rk of first round)) */
   sigma(a,rk);
   for(i = 0; i < 16; i++) rk[i] = k[i];
   gamma(a); 
   pi(a);
   keysched(rk,&rcon); 
   sigma(a,rk);
   for(i = 2; i <= R; i++) {
      theta(a);
      gamma(a); 
      pi(a);
      keysched(rk,&rcon); 
      sigma(a,rk);
      }
   }
